<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini Multiplayer Grid</title>
    <style>
        canvas {
            background: #ddd;
            display: block;
            margin: 20px auto;
            touch-action: none; /* Evita zoom por toque em mobile */
        }

        .joystick {
            position: fixed;
            bottom: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: 80px 80px 80px;
            grid-template-rows: 80px 80px 80px;
            gap: 20px;
            touch-action: none;
        }

        .joystick button {
            width: 80px;
            height: 80px;
            font-size: 28px;
            border-radius: 12px;
            border: none;
            background-color: #f0f0f0;
            user-select: none;
        }

        .joystick button:active {
            background-color: #ccc;
        }

        .joystick button:disabled {
            visibility: hidden;
        }
    </style>
</head>
<body>
<canvas id="game" width="512" height="512"></canvas>

<div class="joystick">
    <button disabled></button>
    <button id="up">↑</button>
    <button disabled></button>
    <button id="left">←</button>
    <button disabled></button>
    <button id="right">→</button>
    <button disabled></button>
    <button id="down">↓</button>
    <button disabled></button>
</div>

<div style="width: 512px; margin: 20px auto;">
    <div id="chatBox" style="height: 150px; overflow-y: auto; background: #f9f9f9; border: 1px solid #ccc; padding: 5px; font-family: monospace; font-size: 14px;"></div>
    <input type="text" id="chatInput" placeholder="Digite sua mensagem e aperte Enter..." style="width: 100%; padding: 5px;">
</div>

<script>
const spriteSheet = new Image();
spriteSheet.src = 'charset/sprite.png';

const frameWidth = 48;
const frameHeight = 72;
const framesPerAnim = 3;
const directions = ["down", "left", "right", "up"];
const charactersPerRow = 4;

const movementSpeed = 200;
const animationStyle = [0,1,2,1];

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let players = [];
let myPlayerID = null;

const ws = new WebSocket('ws://192.168.0.239:8080/ws');

ws.onmessage = function(event) {
    const msg = JSON.parse(event.data);

    if (msg.type === 'init') {
        myPlayerID = msg.id;
    }

    if (msg.type === 'state') {
        players = msg.players.map(p => {
            let existing = players.find(oldP => oldP.id === p.id);
            return {
                ...p,
                x_img: existing ? existing.x_img : p.x * 32,
                y_img: existing ? existing.y_img : p.y * 32,
                animFrame: existing ? existing.animFrame : 0,
                animTime: existing ? existing.animTime : 0
            };
        });
    }

    if (msg.type === 'chat') {
        const chatBox = document.getElementById('chatBox');
        chatBox.innerHTML += `<div><strong>Jogador ${msg.id}:</strong> ${msg.text}</div>`;
        chatBox.scrollTop = chatBox.scrollHeight;
    }
};

document.getElementById('chatInput').addEventListener('keydown', function(event) {
    if (event.key === 'Enter' && this.value.trim() !== '') {
        ws.send(JSON.stringify({ type: 'chat', text: this.value.trim() }));
        this.value = '';
    }
});

function sendMove(dir) {
    ws.send(JSON.stringify({ type: 'move', dir: dir }));
}

const directionsInput = ["up", "down", "left", "right"];
directionsInput.forEach(dir => {
    const btn = document.getElementById(dir);
    btn.addEventListener('mousedown', () => sendMove(dir));
    btn.addEventListener('touchstart', e => { e.preventDefault(); sendMove(dir); }, { passive: false });
});

document.addEventListener('keydown', function(event) {
    if (document.activeElement.id === 'chatInput') return;
    if (event.key === 'w') sendMove('up');
    if (event.key === 's') sendMove('down');
    if (event.key === 'a') sendMove('left');
    if (event.key === 'd') sendMove('right');
});

function lerp(a, b, t) {
    return a + (b - a) * t;
}

function updatePlayerPositions(deltaTime) {
    for (let p of players) {
        const targetX = p.x * 32;
        const targetY = p.y * 32;

        const dx = targetX - p.x_img;
        const dy = targetY - p.y_img;

        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 0.5) {
            const maxStep = (movementSpeed * deltaTime) / 1000;  // deltaTime está em ms
            const step = Math.min(distance, maxStep);
            const ratio = step / distance;
			
            p.x_img += dx * ratio;
            p.y_img += dy * ratio;
        } else {
            p.x_img = targetX;
            p.y_img = targetY;
        }
    }
}

function isPlayerMoving(p) {
    const targetX = p.x * 32;
    const targetY = p.y * 32;
    const dx = Math.abs(p.x_img - targetX);
    const dy = Math.abs(p.y_img - targetY);
    return dx > 1 || dy > 1;
}

function updateAnimations(deltaTime) {
    for (let p of players) {
        if (isPlayerMoving(p)) {
            p.animTime = (p.animTime || 0) + deltaTime;
            if (p.animTime >= 150) {
                p.animTime = 0;
                p.animFrame = animationStyle[(p.animFrame + 1) % framesPerAnim];
            }
        } else {
            p.animFrame = 1;
        }
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const now = performance.now();
    const deltaTime = now - (draw.lastTime || now);
    draw.lastTime = now;

    updatePlayerPositions(deltaTime);
    updateAnimations(deltaTime);

    for (let p of players) {
        const dirIndex = directions.indexOf(p.direction || 'down');
        const charCol = p.characterIndex % charactersPerRow;
        const charRow = Math.floor(p.characterIndex / charactersPerRow);

        const sx = charCol * framesPerAnim * frameWidth + (p.animFrame % framesPerAnim) * frameWidth;
        const sy = charRow * directions.length * frameHeight + dirIndex * frameHeight;

        ctx.drawImage(
            spriteSheet,
            sx, sy, frameWidth, frameHeight,
            p.x_img, p.y_img, frameWidth, frameHeight
        );
    }

    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
