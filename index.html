<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mini Multiplayer Grid</title>
    <style>
        canvas {
            background: #ddd;
            display: block;
            margin: 20px auto;
            touch-action: none;
        }

        .joystick {
            position: relative;
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 10px;
            justify-content: center;
            touch-action: none;
            pointer-events: auto;
            opacity: 0.6;
        }

        .joystick button {
            width: 60px;
            height: 60px;
            font-size: 24px;
            border-radius: 12px;
            border: none;
            background-color: #f0f0f0;
            user-select: none;
        }

        .joystick button:active {
            background-color: #ccc;
        }

        .joystick button:disabled {
            visibility: hidden;
        }

        .joystick-overlay {
            position: absolute;
            bottom: 10px;
            left: 10px;
            pointer-events: none;
        }

        .action-buttons-overlay {
            position: absolute;
            bottom: 10px;
            right: 10px;
            pointer-events: none;
        }

        .action-buttons {
            display: grid;
            grid-template-columns: 60px 60px;
            gap: 10px;
            pointer-events: auto;
            opacity: 0.6;
        }

        .action-buttons button {
            width: 60px;
            height: 60px;
            font-size: 18px;
            border-radius: 12px;
            border: none;
            background-color: #e0e0e0;
            user-select: none;
        }

        .action-buttons button:active {
            background-color: #bbb;
        }
        
    </style>
</head>
<body>
<div id="gameContainer" style="width: 768px; margin: 0 auto;">
    <canvas id="game" width="768" height="512"></canvas>
    <input type="text" id="chatInput" placeholder="Digite sua mensagem e aperte Enter..." 
           style="width: 100%; padding: 6px; box-sizing: border-box; border: none; outline: none; font-family: 'PixelFont', monospace; font-size: 16px;"/>
</div>
<!-- Joystick no canto inferior esquerdo -->
<div class="joystick-overlay">
    <div class="joystick">
        <button disabled></button>
        <button id="up">↑</button>
        <button disabled></button>
        <button id="left">←</button>
        <button disabled></button>
        <button id="right">→</button>
        <button disabled></button>
        <button id="down">↓</button>
        <button disabled></button>
    </div>
</div>

<!-- Botões de ação no canto inferior direito -->
<div class="action-buttons-overlay">
    <div class="action-buttons">
        <button id="btn-z">Z</button>
        <button id="btn-x">X</button>
        <button id="btn-c">C</button>
        <button id="btn-esc">ESC</button>
    </div>
</div>



<script>

const spriteSheet = new Image();
spriteSheet.src = 'charset/sprite.png';

const frameWidth = 48;
const frameHeight = 72;
const framesPerAnim = 3;
const directions = ["down", "left", "right", "up"];
const charactersPerRow = 4;

const movementSpeed = 300;
const animationStyle = [0,1,2,1];

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let players = [];
let myPlayerID = null;

const ws = new WebSocket('ws://192.168.1.38:8080/ws');

ws.onmessage = function(event) {
    const msg = JSON.parse(event.data);

    if (msg.type === 'init') {
        myPlayerID = msg.id;
    }

    if (msg.type === 'state') {
        players = msg.players.map(p => {
            let existing = players.find(oldP => oldP.id === p.id);
            return {
                ...p,
                x_img: existing ? existing.x_img : p.x * 32,
                y_img: existing ? existing.y_img : p.y * 32,
                animFrame: existing ? existing.animFrame : 0,
                animTime: existing ? existing.animTime : 0,
                chatTimestamp: existing?.chatText !== p.chatText ? performance.now() : existing?.chatTimestamp || 0
            };
        });
    }

    if (msg.type === 'chat') {
        const sender = players.find(p => p.id === msg.id);
        if (sender) {
            sender.chatText = msg.text;

            // Remover texto após 10 segundos
            setTimeout(() => {
                if (sender.chatText === msg.text) {
                    sender.chatText = '';
                }
            }, 15000);
        }
    }
};

document.getElementById('chatInput').addEventListener('keydown', function(event) {
    if (event.key === 'Enter' && this.value.trim() !== '') {
        ws.send(JSON.stringify({ type: 'chat', text: this.value.trim() }));
        this.value = '';
    }
});

function sendMove(dir) {
    ws.send(JSON.stringify({ type: 'move', dir: dir }));
}

const directionsInput = ["up", "down", "left", "right"];
directionsInput.forEach(dir => {
    const btn = document.getElementById(dir);
    btn.addEventListener('mousedown', () => sendMove(dir));
    btn.addEventListener('touchstart', e => { e.preventDefault(); sendMove(dir); }, { passive: false });
});


const keysPressed = {};

document.addEventListener('keydown', function(event) {
    if (document.activeElement.id === 'chatInput') return;
    keysPressed[event.key.toLowerCase()] = true;
});

document.addEventListener('keyup', function(event) {
    keysPressed[event.key.toLowerCase()] = false;
});

setInterval(function() {
    if (keysPressed['w']) sendMove('up');
    if (keysPressed['s']) sendMove('down');
    if (keysPressed['a']) sendMove('left');
    if (keysPressed['d']) sendMove('right');
}, 50);


function lerp(a, b, t) {
    return a + (b - a) * t;
}

function updatePlayerPositions(deltaTime) {
    for (let p of players) {
        const targetX = p.x * 32;
        const targetY = p.y * 32;

        const dx = targetX - p.x_img;
        const dy = targetY - p.y_img;

        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 0.5) {
            const maxStep = (movementSpeed * deltaTime) / 1000;  // deltaTime está em ms
            const step = Math.min(distance, maxStep);
            const ratio = step / distance;
            p.x_img += dx * ratio;
            p.y_img += dy * ratio;
        } else {
            p.x_img = targetX;
            p.y_img = targetY;
        }
    }
}

function isPlayerMoving(p) {
    const targetX = p.x * 32;
    const targetY = p.y * 32;
    const dx = Math.abs(p.x_img - targetX);
    const dy = Math.abs(p.y_img - targetY);
    return dx > 0.1 || dy > 0.1;
}

function updateAnimations(deltaTime) {
    for (let p of players) {
        if (isPlayerMoving(p)) {
            p.animTime = (p.animTime || 0) + deltaTime;
            if (p.animTime >= 150) {
                p.animTime = 0;
                p.animFrame = animationStyle[(p.animFrame + 1) % framesPerAnim];
            }
        } else {
            p.animFrame = 1;
        }
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const now = Date.now();
    const deltaTime = now - (draw.lastTime || now);
    draw.lastTime = now;

    updatePlayerPositions(deltaTime);
    updateAnimations(deltaTime);

    for (let p of players) {
        const dirIndex = directions.indexOf(p.direction || 'down');
        const charCol = p.characterIndex % charactersPerRow;
        const charRow = Math.floor(p.characterIndex / charactersPerRow);

        const sx = charCol * framesPerAnim * frameWidth + (p.animFrame % framesPerAnim) * frameWidth;
        const sy = charRow * directions.length * frameHeight + dirIndex * frameHeight;

        ctx.drawImage(
            spriteSheet,
            sx, sy, frameWidth, frameHeight,
            p.x_img, p.y_img, frameWidth, frameHeight
        );

        // Desenhar até 5 mensagens empilhadas
        if (p.chatMessages && p.chatMessages.length > 0) {
            const messages = p.chatMessages.slice(-3); // últimas 5 mensagens
            let yOffset = 0;

            for (let i = messages.length - 1; i >= 0; i--) {
                const msg = messages[i];
                const elapsed = now - msg.timestamp;

                if (elapsed >= 15000) continue; // Ignora mensagens expiradas

                let opacity = 1;
                if (elapsed > 10000) {
                    opacity = 1 - ((elapsed - 10000) / 5000);
                }

                ctx.save();
                ctx.globalAlpha = opacity;

                ctx.font = "14px sans-serif";
                const text = msg.text;
                const textWidth = ctx.measureText(text).width;

                const x = p.x_img + frameWidth / 2;
                const y = p.y_img - 10 - yOffset;

                // Fundo arredondado da mensagem
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
                ctx.beginPath();
                ctx.roundRect(x - textWidth / 2 - 6, y - 20, textWidth + 12, 20, 6);
                ctx.fill();

                // Texto da mensagem
                ctx.fillStyle = "white";
                ctx.fillText(text, x - textWidth / 2, y - 5);

                ctx.restore();

                yOffset += 20;
            }
        }
    }

    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
